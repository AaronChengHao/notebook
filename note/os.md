###线程：

每个函数是由数据和代码构成的一段数据。
每个线程内都是由一个栈，保存了多个函数执行的栈顶指针。通过压栈和弹栈来切换函数执行。
TCB是thread control block，是一个全局数据结构，用来保存各个栈的栈顶指针，通过栈顶指针的切换实现线程的切换。
ESP寄存器：是存储 当前执行函数栈顶指针 也就是TCB地址 的寄存器。
CS,IP是两个寄存器分别保存着段基址和偏移地址，通过两者配合构成一个概念PC，即指向下一条要执行的代码地址。

用户态线程的切换：ESP指向不同的TCB->指向了不同的栈代码块->指向了不同的线程->指向了各线程的初始执行地址->执行切换。

线程的切换只需要内存操作，很快，而进程还要包括其内存映射表。多线程的价值：在进程进行I/O的时候，另一个线程也可以操作进程共享数据，其他的线程等待IO完成。

用户态线程切换五段论：
1. 通过INT指令或I/O中断从`A用户态`线程进入`A内核态`线程；
2. 在线程create时创建`B内核态栈`结构，括 SS:SP 分别指向用户态线程栈（此栈保存的是此线程各函数的首地址）的起点和终点地址，PC 指向从内核态返回时要执行的代码地址， CS指向的是线程的段基址。
3. 找到TCB;
4. 通过`TCB`切换到B内核态线程。
5. 使用IRET从B内核态中返回，依次弹内`B核态栈`，通过各地址返回回`B用户态`线程。

###内存分段
为了使内存能够被分治，需要根据内存的用途对每个进程的内存进行分段。
其中：
- 代码段：只读
- 数据读：可读写
- 堆栈段：向下增长

进行内存寻址时，使用段基址(DS) 和段偏移(CS)
进程PCB内部存在一个段表(LDT)，存放各个段的内存基址；如果操作系统是一个进程，GDT表则是它的段表；

###内存分页
为了避免内存分配时的碎片问题，将内存进行分页。
将内存分成4K一页后再进行内存分配，如此，一段内存最多也只会浪费 4K内存，使用页表来存储页号和内存范围的映射。
较大的内存在分布后页表非常大（4G/4K=4M），造成浪费，所以使用多级页表进行多级索引。
又由于程序的局部性，将常用的页表寻址保存到寄存器，是为快表 TLB。

###内存寻址
分段是方便用户的使用，而分页方便内存的分配和寻址，而段页配合使用需要一个中间概念：`虚拟地址`。
在用户操作时，先进行虚拟内存的分段，再将虚拟内存的一段内存打散为页后分布在真实内存上。

内存寻址时通过 逻辑地址-虚拟地址-物理地址 进行转换。
逻辑地址的段寄存器提供段描述符，由段描述符查找`LDT段表`得到段基址和段界限，再加上逻辑地址的寄存器中的偏移量，得到了虚拟地址，线性地址通过分页机制查找`页表`得到真实的物理地址。

###进程和线程
进程通常包括三部分：
- 程序：可执行代码；
- 资源：内存、I/O、信号等；
- 执行：执行上下文，对CPU的占用，寄存器；

进程是内存等资源分配的基本单位，线程是CPU调度的基本单位
进程至少拥有一个线程，CPU调度的实际上是一个线程。
每个CPU有自己的就绪任务队列，线程就被放在就绪队列内。

进程：进程是对任务的一个抽象，在操作系统中只是一些数据，包括`segment、heap、.rodata、data、bss、.text`部分。
线程：是CPU执行代码的一个抽象，使用进程的 stack保存自己的函数调用过程。其他数据使用进程的。

比方： 笔记本是CPU资源，一个项目组是进程，一个程序员是线程。 一个项目组内可能会有多个程序员，而且使用笔记本的是程序员，多个笔记本支持多个程序员同时工作。多个程序员共享组内的食物、座位、水等资源。 每个程序员只能使用自己的纸记录自己在笔记本上工作到了什么状态。

操作系统时间片中断后所有线程都会被切走吗？不会，多个CPU可以并行执行多个线程
进程状态与线程状态的关系？进程是无状态的，只有线程状态

###栈
1. 进程栈：每个进程都有一套页表，对进程而言好像是独享了整个内存空间。
        linux中四分之一是内核内存空间，四分之三是进程内存空间。
        进程栈在进程内存空间的高地址，存放了函数的参数值，局部变量等数据。
        此栈可以动态增长，最大一般为8M，可以通过 `ulimit -s` 来查看
2. 线程栈：在linux中，线程是一个特殊的线程，都使用`task_struct`表示。
        进程与线程的唯一区别是`是否内存共享`，线程的内存描述符直接指向父进程的内存描述符`tsk->mm = current->mm`;
3. 进程内核栈：每个进程都会进入到内核态执行，在内核态使用特定的栈-进程内核栈，线程。
4. 中断栈： 系统中断时，系统会进入内核态，操作系统保存正在运行代码的当前状态，执行中断处理函数。

###阻塞与唤醒
- 进程执行到阻塞代码（一般是网络或磁盘I/O）后，会发生操作系统调度，当前进程会被置为 SLEEP；
- 当网络或磁盘I/O响应后，硬件会向CPU发出中断指令，CPU处理中断上半部确认收到中断指令，下半部执行缓冲区的复制，完成后会将正在SLEEP的进程状态置为RUNNING，再发生操作系统调度后，进程就可能会被执行到。

###系统内存分类
操作系统分配高位的四分之一内存给内核，如32位系统下内核拥有1G内存，操作系统将这部分内存分为三部分：

- DMA： 3G - 3G+16M， 为了防止在硬件大量数据时，操作系统将所有时间都响应中断，操作系统允许硬件直接向内存传输数据，一般系统调用 read，系统分配一个DMA缓冲区让硬件往里面写数据，在写入完毕后产生一个中断，操作系统唤起进程处理数据；
- NORMAL： 3G+16M - 3G+896M， 此部分内存映射到虚拟内存上使用
- 高端内存：，为了使内核能够访问剩下的内存，内核将高位的 128M （3G+896M - 4G）留下来 作为动态映射物理内存，而将剩下的 896M直接映射到虚拟内存上使用；在64机器上，内核能映射超过512G内存，不需要高端内存；

















