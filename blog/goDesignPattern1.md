设计模式，Let's "Go"！ (上)

PHP程序员阅读Java语言实现设计模式的书，然后用Go语言实现的设计模式，配以现实生活中的实例，帮助理解设计模式。本篇包括：策略、观察者、装饰者、工厂、单例、命令、适配器、外观。

#前言

最近读了《Head First 设计模式》，每天早上看一章，学习一个设计模式，做些笔记，然后晚上抽空用刚学习的 Go 语言实现一下。半个月下来书读完了，留下了一些笔记，写博客总结一下。

书中的例子都是 Java 写的，但几乎没使用 Java 语言的特性，很容易看懂。对于我来说，就是一个 PHP 开发工程师，读了一本 用 Java 语言实现设计模式的书，然后用 Go 写了一遍。。。=_=

本文为每个设计模式只分配了一小节，总结一下设计模式的概念和特点以及适用场景，并介绍了自己用代码实现时的列举的例子，用现实生活中的事物对比加深一下记忆 （ 代码实现中所有的例子都是自己原创的，有牵强的部分，不要介意）。每个模式篇幅不大，可以给新人入门，给了解过设计模式的人作为速查。

文章经常被人爬，而且还不注明原地址，我在这里的更新和纠错没法同步，这里注明一下原文地址：  以防误人子弟。

放上 Go 实现设计模式的 源码地址：[DesignPattern-枕边书-Github](https://github.com/zhenbianshu/DesignPattern) ，偶有更新，欢迎 `star`。OK，正文开始。

---
#策略模式(Strategy)
###介绍
策略模式： 将算法或操作抽象成`实现共同接口、可以被替换`的类，实现逻辑和具体算法的解耦。

- 将各种行为`抽象成算法`，封装算法为对象； 
- 算法实现`共同接口`，调用者调用时不考虑算法具体实现，调用接口方法即可；
- 调用者可随时替换此算法对象；


###场景
- 多个方法择一使用，且他们会被随时替换；
- 方法没有共性，使用继承会有大量重写，使用接口会有大量重复使用；

###实现
1. 两个算法： 冒泡排序和快速排序；
2. 抽象冒泡排序和快速排序为算法对象，实现算法接口，拥有 used() 被使用方法；
3. 计算器计算时不用理会是什么算法，调用 used() 即可。


---
#观察者模式(Observer)
###介绍
观察者模式：主题`主动向观察者推送`变化，解决观察者对主题对象的依赖。

- 观察者实现`被通知`接口，并在主题上注册，主题只`保存观察者的引用`，不关心观察者的实现；
- 在主题有变化时调用观察者的通知接口来通知已注册的观察者；
- 通知方式有`推`（主题变化时将变化数据推送给观察者）和`拉`（主题只告知变化，观察者主动来拉取数据）

###场景
- 一个主题，多个观察者，主题的任何变动，观察者都要第一时刻得到；
- 观察者获取主题变化困难，定时不及时，轮询消耗大；
- 观察者可以随时停止关注某主题；

###实现
1. 张三和李四是记者，他们需要及时了解城市发生的新闻；
2. 张三和李四在电视台注册了自己的信息；
3. 城市发生了新闻，电视台遍历注册信息，通知了张三和李四；
4. 李四退休了，在电视台注销了自己的信息；
5. 城市又发生了新闻，电视台只通知了张三；


---
#装饰者模式(Decorator)

###介绍
装饰者模式：包装一个对象，在被装饰对象的基础上`添加功能`；

- 装饰者与被装饰对象拥有同一个超类，`装饰者拥有被装饰对象的所有外部接口`，可被调用，外界无法感知调用的是装饰者还是被装饰者；
- 装饰者需要被装饰者作为参数传入，并在装饰者内部，在`被装饰者实现的基础上添加或修改某些功能`后，提供同被装饰者一样的接口；
- 装饰者也可被另一个装饰者装饰，即嵌套装饰。
- 装饰者是一群包装类，由于装饰的复杂性，会多出很多个装饰者小类；


###场景
- 对象需要动态地添加和修改功能；
- 功能改变后不影响原对象的使用

###实现
1. 在商店内，花作为被装饰者对象、红丝带和盒子作为花的装饰者；
2. 花、红丝带、盒子有共同的超类“商品”，他们都能被卖掉；
3. 我们可以在红丝带装饰过花后，再用盒子再包装一次；
4. 包装后的花，顾客买时也不会受到任何影响；

---
#工厂模式(Factory)

###介绍
工厂模式： 顾名思义，工厂模式是`对象的生产器`，解耦用户对具体对象的依赖。

- 实现`依赖倒置`，让用户通过一个"产品工厂"`依赖产品的抽象`，而不是一个具体的产品；
- 简单工厂模式：接收参数并根据参数创建对应类，将对象的实例化和具体使用解耦；
- 抽象工厂模式：将工厂`抽象出多个生产接口`，不同类型的工厂调用生产接口时，生产不同类型的对象；
- 简单工厂常配合抽象工厂一起使用；

###场景
- 根据不同条件需求不同的对象；
- 对象实例化的代码经常需要修改；

###实现
1. 简单工厂：向鞋厂内传入不同的类型（布制），鞋厂会生产出不同类型的鞋子（布鞋）；
2. 抽象工厂：有两座鞋厂：李宁鞋厂、Adidas鞋厂，他们能生产对应各自品牌的鞋子；
3. 搭配使用：向不同的抽象工厂（李宁）传入不同的类型（运动类型），会生产出对应品牌对应类型的鞋子（李宁运动鞋）；

---
#单例模式(Singleton)
###介绍
单例模式：保证同一个类`全局只有一个实例对象`;

- 在第一次实例化后会使用`静态变量保存`实例，后续全局使用此静态变量；
- 一般将构造方法私有化，构造方法添加 final 关键字无法被重写，添加一个类静态方法用于返回此实例；
- 在多线程时应该考虑`并发`问题，防止两次调用都被判定为实例未初始化而重复初始化对象；

###场景
- 全局共享同一个实例对象（数据库连接等）；
- 某一处对此对象的更新全局可见；

###实现
1. 利用 Go 中包的可见性规则来隐藏对象的实例化权限；
2. 使用包变量保存实例对象，获取实例时判断是否已实例化，如为nil，实例化对象并返回，如有值，直接返回值；
3. 待用锁实现 Go routine 并发时的问题；

----
#命令模式(Command)
###介绍
命令模式:将一个`命令封装成对象`，解耦命令的发起者和执行者。

- 命令对象实现`命令接口（excute[、undo]）`，命令发起者实例化命令对象，并传递此对象，并不关心此对象由谁执行；
- 命令执行者只负责调用命令对象的执行方法即可，不关心对象是由谁生成的；
- 与策略模式不同之处：策略模式是通过不同的算法做同一件事情（例如排序），而命令模式则是通过不同的命令做不同的事情；

###场景
- 命令发起者与执行者无法直接接触；
- 命令需要撤销功能，却不易保存命令执行状态信息时；

###实现
1. 指挥官创建了一个“从树下跑到草地上”的命令；
2. 命令被分配给张三执行，张三作为军人，接到命令后不管命令的具体内容，而是直接调用命令的执行接口执行。
3. 指挥官发布了撤销指令，张三又从草地上跑到了树下。

---
#适配器模式(Adapter)
###介绍
适配器模式：包装对象提供一个接口，以`适配调用者`。

- 适配器通过一个中间对象，`封装目标接口`以`适应调用者`调用；
- 调用者调用此适配器，以达到调用目标接口的目的；
- 适配器模式与装饰者模式的不同之处：适配器模式不改变接口的功能，而装饰者会添加或修改原接口功能；

###场景
- 提供的接口与调用者调用的其他的接口都不一致；
- 为一个特殊接口修改调用者的调用方式得不偿失；

###实现
1. 张三是个正常人，他能通过说话直接地表达自己；
2. 李四是个聋哑人，他没法直接表达自己，但他会写字。
3. 笔记本作为一个适配器，用笔记本“包装”了李四之后，当李四需要表达自己想法时，调用笔记本的“表达”功能，笔记本再调用李四“写字”的方法。

---
#外观模式(Facade)
###介绍
外观模式：通过`封装多个复杂的接口`来提供一个`简化接口`来实现一个复杂功能。

- 外观模式是通过封装多个接口来将接口`简单化`；
- 外观模式不会改变原有的多个复杂的单一接口，这些接口依然能被单独调用，只是提供了一个额外的接口；
- 外观模式与适配器模式的不同之处：外观模式是`整合`多个接口并`添加`一个简化接口，适配器是适配一个接口；

###场景
- 实现某一功能需要调用多个复杂接口；
- 经常需要实现此功能，

###实现
1. 正常的冲咖啡步骤是：磨咖啡豆、烧开水、倒开水搅拌咖啡。
2. 我们经常需要直接冲咖啡，而不是使用单一步骤，每次喝咖啡时调用三个方法很麻烦；
3. 封装三个接口，额外提供一个 “冲咖啡” 的方法，需要喝咖啡时只需要调用一次冲咖啡方法即可。

---
#小结
《Head First 设计模式》这书真心不错，例子很轻松，给人很多时间和空间来思考，同时介绍模式时使用结合故事，层层深入的方法，让人印象很深刻，推荐。

书中详细介绍了 14 个基础设计模式，还有 9 个简化版，就自己查资料结合自己的理解来总结了。

本系统准备写三篇，敬请期待中下篇。

关于本文有什么问题可以在下面留言交流，如果您觉得本文对您有帮助，可以点击下面的 **推荐** 支持一下我。博客一直在更新，欢迎 **关注** 。